# VAD 流式切分功能调试回顾

**日期:** 2025-12-12  
**状态:** 已放弃 / 回退至 Master 分支  
**组件:** Electron 前端 (VAD 服务)

## 1. 问题描述

用户试图实现“VAD 模式”，在该模式下系统应在用户说话时执行音频的**流式切分**。预期的行为是 VAD (语音活动检测) 模块能够实时检测静音间隔并切分/发送音频块。

**观察到的行为：**
- VAD 模块在录音期间未能将语音转换为切片。
- 切分仅在用户手动停止录音后发生。
- 即使验证了“Unlimited 模式”（逻辑上手动阻止切分）能正确传递音频，VAD 模式在实际运行中的表现却与 Unlimited 模式类似（无限堆积缓冲区）。

## 2. 调试过程

### 2.1 音频流验证
**假设：** VAD 模块接收到的音频数据可能与波形图看到的静音或损坏数据不同。

**行动：**
- 对 `Waveform` 组件和 `useVADRecording` hook 进行了插桩。
- 使用共享的 `debugSessionId` 实现了同步调试录音机制。
- 捕获了完全相同时间窗口的 `_wave.wav`（前端可视化输入）和 `_vad.wav`（VAD 处理输入）。

**结果：**
- 两个 WAV 文件都包含有效、清晰的音频。
- 这排除了 `AudioContext` 重采样或音频捕获管道的问题。VAD 模块接收到了正确的音频数据。

### 2.2 内部逻辑探查
**假设：** VAD 算法在运行，但检测到的概率过低。

**行动：**
- 在 `processAudioChunk` 循环内部，特别是在 `vad.detect()` 调用之后插入了日志探针。
- 分析 `speechProb`（语音概率）和 `Amp`（振幅）的日志。

**结果：**
- 日志显示振幅很高（例如 `Amp=0.44`，明显在说话），但语音概率极低（例如 `Prob=0.004`）。
- 由于从未达到概率阈值，`isSpeaking` 状态从未被触发，因此“说话后的静音”切分逻辑从未执行。

### 2.3 模型输出分析（发现根因）
**假设：** 对 ONNX 模型输出的解读是错误的。

**调查：**
- 审查了 `funasrVAD.ts` 的输出解析逻辑。代码假设模型输出是一个简单的 2D 数组（或代表 `[静音, 语音]` 的扁平数组）。
- 检查了模型配置 (`vad.yaml`)。
- **关键发现：**
    - FSMN-VAD 模型的输出维度是 **248**，而不是 2。
    - 输出代表 248 个声学状态的原始 **logits**，而不是简单的归一化概率分布。
    - `vad.yaml` 定义了 `sil_pdf_ids: [0]`，这意味着索引 0 是静音状态，其余代表语音状态。
    - 现有代码基于错误的形状假设，错误地对索引进行了求和或平均。

## 3. 尝试修复与结论

**提议的修复：**
- 实现一个 `softmax` 函数将原始 logits 转换为概率。
- 正确计算：`静音概率 = softmax(output)[0]` 以及 `语音概率 = 1 - 静音概率`。

**结果：**
- 虽然找到了根本原因并构建了修复原型，但用户决定**放弃当前的调试分支** (`vad_bug`) 并将代码库回退到 `master` 分支。
- 修复 ONNX 运行时集成以及验证自定义 Softmax 实现的数值稳定性被认为超出了当前会话的范围。

## 4. 总结
VAD 流式切分失败的原因是 **ONNX 模型输出形状（248维 logits）与前端 TypeScript 实现期望（2维概率）不匹配**。未来如果要修复此功能，必须解决张量形状不匹配的问题，并严格遵循 FunASR 后处理规范。
