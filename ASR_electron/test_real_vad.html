<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FunASR VAD çœŸå®æ¨¡å‹æµ‹è¯•</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 40px auto;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        h1 {
            color: #4CAF50;
            text-align: center;
        }

        .info {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #3a3a3a;
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .label {
            font-weight: bold;
            color: #888;
        }

        .value {
            color: #4CAF50;
            font-family: monospace;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        input[type="file"] {
            flex: 1;
            padding: 10px;
            background: #2a2a2a;
            border: 2px solid #3a3a3a;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .start-btn {
            background: #4CAF50;
            color: white;
        }

        .start-btn:hover:not(:disabled) {
            background: #45a049;
        }

        .stop-btn {
            background: #f44336;
            color: white;
        }

        .stop-btn:hover:not(:disabled) {
            background: #da190b;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress {
            background: #2a2a2a;
            height: 30px;
            border-radius: 6px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .log {
            background: #0a0a0a;
            padding: 15px;
            border-radius: 6px;
            max-height: 500px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            margin-top: 20px;
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #2a2a2a;
        }

        .log-speech {
            color: #4CAF50;
        }

        .log-silence {
            color: #999;
        }

        .log-chunk {
            color: #2196F3;
            font-weight: bold;
        }

        .log-error {
            color: #f44336;
        }

        .log-info {
            color: #FFC107;
        }

        .log-warn {
            color: #FF9800;
        }

        .chunks-summary {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .chunk-card {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #4CAF50;
        }

        .chunk-number {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .chunk-detail {
            font-size: 12px;
            color: #888;
            margin: 5px 0;
        }
    </style>
</head>

<body>
    <h1>ğŸ¤ FunASR VAD çœŸå®æ¨¡å‹æµ‹è¯•</h1>

    <div class="info">
        <div class="info-item">
            <span class="label">VAD çŠ¶æ€:</span>
            <span class="value" id="vadStatus">æœªåˆå§‹åŒ–</span>
        </div>
        <div class="info-item">
            <span class="label">æ¨¡å‹è·¯å¾„:</span>
            <span class="value" id="modelPath">/models/model.onnx</span>
        </div>
        <div class="info-item">
            <span class="label">CMVN è·¯å¾„:</span>
            <span class="value" id="cmvnPath">/models/vad.mvn</span>
        </div>
        <div class="info-item">
            <span class="label">æµ‹è¯•çŠ¶æ€:</span>
            <span class="value" id="testStatus">ç­‰å¾…éŸ³é¢‘æ–‡ä»¶</span>
        </div>
        <div class="info-item">
            <span class="label">æ£€æµ‹åˆ°åˆ‡ç‰‡:</span>
            <span class="value" id="chunkCount">0</span>
        </div>
        <div class="info-item">
            <span class="label">å¤„ç†è¿›åº¦:</span>
            <span class="value" id="progressText">0%</span>
        </div>
    </div>

    <div class="controls">
        <input type="file" id="audioFile" accept=".wav" />
        <button class="start-btn" id="startBtn" onclick="startTest()" disabled>å¼€å§‹æµ‹è¯•</button>
        <button class="stop-btn" id="stopBtn" onclick="stopTest()" disabled>åœæ­¢æµ‹è¯•</button>
    </div>

    <div class="progress">
        <div class="progress-bar" id="progressBar" style="width: 0%">0%</div>
    </div>

    <div id="chunksSummary" class="chunks-summary" style="display: none;"></div>

    <div class="log" id="log"></div>

    <script type="module">
        import { FunASRVAD } from './src/services/funasrVAD.js';

        const VAD_CONFIG = {
            speechThreshold: 0.1,
            silenceThreshold: 0.35,
            minSpeechDurationMs: 200,
            minSilenceDurationMs: 500,
        };

        const SAMPLE_RATE = 16000;
        const BUFFER_SIZE = 2048;
        const BUFFER_SIZE_MS = Math.floor(BUFFER_SIZE * 1000 / SAMPLE_RATE);

        let vad = null;
        let audioData = null;
        let isRunning = false;
        let chunks = [];

        // åˆå§‹åŒ– VAD
        window.addEventListener('DOMContentLoaded', async () => {
            log('ğŸ”„ æ­£åœ¨åˆå§‹åŒ– FunASR VAD æ¨¡å‹...', 'info');
            document.getElementById('vadStatus').textContent = 'åŠ è½½ä¸­...';

            try {
                vad = new FunASRVAD(VAD_CONFIG);
                await vad.init('/models/model.onnx', '/models/vad.mvn');

                document.getElementById('vadStatus').textContent = 'âœ… å·²å°±ç»ª';
                log('âœ… FunASR VAD æ¨¡å‹åŠ è½½å®Œæˆ', 'info');
                log(`   - è¯­éŸ³é˜ˆå€¼: ${VAD_CONFIG.speechThreshold}`, 'info');
                log(`   - é™éŸ³é˜ˆå€¼: ${VAD_CONFIG.silenceThreshold}`, 'info');
                log(`   - é™éŸ³è§¦å‘: ${VAD_CONFIG.minSilenceDurationMs}ms\n`, 'info');

                document.getElementById('audioFile').disabled = false;
            } catch (err) {
                document.getElementById('vadStatus').textContent = 'âŒ å¤±è´¥';
                log('âŒ VAD åˆå§‹åŒ–å¤±è´¥: ' + err.message, 'error');
                console.error(err);
            }
        });

        // éŸ³é¢‘æ–‡ä»¶é€‰æ‹©
        document.getElementById('audioFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            log(`ğŸ“‚ è¯»å–éŸ³é¢‘æ–‡ä»¶: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`, 'info');
            document.getElementById('testStatus').textContent = 'åŠ è½½éŸ³é¢‘...';

            try {
                const arrayBuffer = await file.arrayBuffer();
                const audioContext = new AudioContext({ sampleRate: SAMPLE_RATE });
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                // è½¬æ¢ä¸º Float32Array mono
                const channelData = audioBuffer.getChannelData(0);
                audioData = new Float32Array(channelData);

                const durationSec = audioData.length / SAMPLE_RATE;
                log(`âœ… éŸ³é¢‘åŠ è½½å®Œæˆ: ${audioData.length} æ ·æœ¬, ${durationSec.toFixed(2)}ç§’`, 'info');

                document.getElementById('testStatus').textContent = 'å°±ç»ª';
                document.getElementById('startBtn').disabled = false;

                await audioContext.close();
            } catch (err) {
                log('âŒ éŸ³é¢‘åŠ è½½å¤±è´¥: ' + err.message, 'error');
                console.error(err);
            }
        });

        // å¼€å§‹æµ‹è¯•
        window.startTest = async function () {
            if (!vad || !audioData) return;

            isRunning = true;
            chunks = [];
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('audioFile').disabled = true;
            document.getElementById('testStatus').textContent = 'æµ‹è¯•ä¸­...';
            document.getElementById('chunksSummary').style.display = 'none';
            document.getElementById('chunksSummary').innerHTML = '';

            log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            log('ğŸ¯ å¼€å§‹ VAD æµ‹è¯• (ä½¿ç”¨çœŸå® FunASR ONNX æ¨¡å‹)', 'info');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n', 'info');

            let speechBuffer = [];
            let silenceFrames = 0;
            let speechFrames = 0;
            let isSpeaking = false;
            let chunkCount = 0;

            const totalFrames = Math.floor(audioData.length / BUFFER_SIZE);

            for (let i = 0; i < totalFrames && isRunning; i++) {
                const start = i * BUFFER_SIZE;
                const end = Math.min(start + BUFFER_SIZE, audioData.length);
                const chunk = audioData.slice(start, end);

                if (chunk.length < BUFFER_SIZE) break;

                try {
                    // ä½¿ç”¨çœŸå®çš„ FunASR VAD æ¨¡å‹
                    const speechProb = await vad.detect(chunk);

                    // æ›´æ–°è¿›åº¦
                    const progress = ((i / totalFrames) * 100).toFixed(1);
                    document.getElementById('progressBar').style.width = progress + '%';
                    document.getElementById('progressBar').textContent = progress + '%';
                    document.getElementById('progressText').textContent = progress + '%';

                    if (speechProb >= VAD_CONFIG.speechThreshold) {
                        // æ£€æµ‹åˆ°è¯­éŸ³
                        speechFrames++;
                        silenceFrames = 0;

                        if (!isSpeaking && speechFrames >= 2) {
                            isSpeaking = true;
                            const timestamp = (i * BUFFER_SIZE / SAMPLE_RATE).toFixed(2);
                            log(`ğŸ”Š [${timestamp}s] å¼€å§‹è¯´è¯ (prob=${speechProb.toFixed(3)})`, 'speech');
                        }

                        speechBuffer.push(chunk);

                    } else if (speechProb < VAD_CONFIG.silenceThreshold) {
                        // æ£€æµ‹åˆ°é™éŸ³
                        silenceFrames++;
                        speechFrames = 0;

                        // VAD æ¨¡å¼ï¼šå§‹ç»ˆç¼“å†²
                        speechBuffer.push(chunk);

                        // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡åˆ†
                        const silenceDurationMs = silenceFrames * BUFFER_SIZE_MS;
                        if (silenceDurationMs >= VAD_CONFIG.minSilenceDurationMs && isSpeaking) {
                            const timestamp = (i * BUFFER_SIZE / SAMPLE_RATE).toFixed(2);

                            if (speechBuffer.length > 0) {
                                const totalSamples = speechBuffer.reduce((sum, buf) => sum + buf.length, 0);
                                const durationSec = (totalSamples / SAMPLE_RATE).toFixed(2);
                                const sizeKB = (totalSamples * 4 / 1024).toFixed(1);

                                chunkCount++;
                                document.getElementById('chunkCount').textContent = chunkCount;

                                log(`ğŸ”‡ [${timestamp}s] æ£€æµ‹åˆ°é™éŸ³ ${silenceDurationMs}msï¼Œæ‰§è¡Œåˆ‡åˆ†`, 'silence');
                                log(`âœ‚ï¸  éŸ³é¢‘å— #${chunkCount} | ${totalSamples} æ ·æœ¬ | ${durationSec}s | ${sizeKB}KB`, 'chunk');

                                chunks.push({
                                    index: chunkCount,
                                    timestamp: parseFloat(timestamp),
                                    samples: totalSamples,
                                    duration: parseFloat(durationSec),
                                    sizeKB: parseFloat(sizeKB)
                                });

                                speechBuffer = [];
                                silenceFrames = 0;
                            }

                            isSpeaking = false;
                        }
                    }
                } catch (err) {
                    log('âŒ VAD å¤„ç†é”™è¯¯: ' + err.message, 'error');
                    console.error(err);
                }

                // è®©å‡ºæ§åˆ¶æƒï¼Œé¿å…é˜»å¡ UI
                if (i % 100 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            // å¤„ç†å‰©ä½™ç¼“å†²
            if (speechBuffer.length > 0) {
                const totalSamples = speechBuffer.reduce((sum, buf) => sum + buf.length, 0);
                const durationSec = (totalSamples / SAMPLE_RATE).toFixed(2);
                const sizeKB = (totalSamples * 4 / 1024).toFixed(1);

                chunkCount++;
                document.getElementById('chunkCount').textContent = chunkCount;

                log(`âœ‚ï¸  [æœ€å] éŸ³é¢‘å— #${chunkCount} | ${totalSamples} æ ·æœ¬ | ${durationSec}s | ${sizeKB}KB`, 'chunk');

                chunks.push({
                    index: chunkCount,
                    timestamp: 0,
                    samples: totalSamples,
                    duration: parseFloat(durationSec),
                    sizeKB: parseFloat(sizeKB)
                });
            }

            // æ˜¾ç¤ºæ€»ç»“
            log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
            log(`âœ… æµ‹è¯•å®Œæˆï¼`, 'info');
            log(`   æ€»åˆ‡ç‰‡æ•°: ${chunkCount}`, 'info');
            log(`   æ€»å¸§æ•°: ${totalFrames}`, 'info');
            log(`   éŸ³é¢‘æ—¶é•¿: ${(audioData.length / SAMPLE_RATE).toFixed(2)}s`, 'info');

            if (chunks.length > 0) {
                const avgDuration = chunks.reduce((sum, c) => sum + c.duration, 0) / chunks.length;
                log(`   å¹³å‡åˆ‡ç‰‡æ—¶é•¿: ${avgDuration.toFixed(2)}s`, 'info');
            }
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n', 'info');

            // æ˜¾ç¤ºåˆ‡ç‰‡å¡ç‰‡
            displayChunksSummary();

            document.getElementById('testStatus').textContent = 'å®Œæˆ';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('audioFile').disabled = false;
            isRunning = false;

            vad.reset();
        };

        // åœæ­¢æµ‹è¯•
        window.stopTest = function () {
            isRunning = false;
            log('ğŸ›‘ æµ‹è¯•å·²åœæ­¢', 'warn');
            document.getElementById('testStatus').textContent = 'å·²åœæ­¢';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('audioFile').disabled = false;
            vad?.reset();
        };

        // æ˜¾ç¤ºåˆ‡ç‰‡æ€»ç»“
        function displayChunksSummary() {
            const container = document.getElementById('chunksSummary');
            container.innerHTML = '';

            if (chunks.length === 0) return;

            container.style.display = 'grid';

            chunks.forEach(chunk => {
                const card = document.createElement('div');
                card.className = 'chunk-card';
                card.innerHTML = `
                    <div class="chunk-number">#${chunk.index}</div>
                    <div class="chunk-detail">â±ï¸ ${chunk.duration}s</div>
                    <div class="chunk-detail">ğŸ“Š ${chunk.samples} æ ·æœ¬</div>
                    <div class="chunk-detail">ğŸ’¾ ${chunk.sizeKB} KB</div>
                    ${chunk.timestamp > 0 ? `<div class="chunk-detail">ğŸ• ${chunk.timestamp}s</div>` : ''}
                `;
                container.appendChild(card);
            });
        }

        // æ—¥å¿—å‡½æ•°
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
    </script>
</body>

</html>