# Dev: 本地录音保留与长录音分段处理开发记录

**工作类型**: development  
**创建时间**: 2025-11-04 11:10:56  
**基于 Solution 版本**: 2025-11-04 11:03:18

---

## 已完成任务

### MODULE-001: 录音文件管理模块 ✅

**文件**: `src/helpers/audioFileManager.js`（新建）

**涉及的类**:
- `AudioFileManager` - 录音文件管理器

**涉及的方法**:
1. `initialize()` - 初始化录音目录
   - 功能：创建 `recordings/` 目录
   - 返回：`{ success, path }`

2. `getRecordingsDirectory()` - 获取录音目录路径
   - 功能：根据开发模式 vs 生产模式返回不同路径
   - 开发模式：`项目根目录/recordings/`
   - 生产模式：`用户数据目录/recordings/`
   - 返回：目录路径字符串

3. `saveRecording(audioBlob, timestamp)` - 保存录音文件
   - 参数：`audioBlob` (音频数据), `timestamp` (时间戳字符串)
   - 功能：保存录音文件，使用时间戳命名，自动清理旧文件
   - 返回：`{ success, filePath, relativePath, size }`

4. `cleanupOldRecordings()` - 清理旧录音
   - 功能：保留最近 10 条录音，删除多余的
   - 返回：`{ success }`

5. `getRecordingsList()` - 获取录音列表
   - 功能：返回所有录音文件，按时间倒序
   - 返回：`[ { name, path, size, created_at }, ... ]`

6. `deleteRecording(filePath)` - 删除指定录音
   - 参数：文件路径
   - 返回：`{ success }`

**实现思路**:
- 使用 Node.js `fs` 模块进行文件操作
- 文件命名格式：`YYYYMMDD_HHMM_recording.wav`
- 保存文件后自动触发清理逻辑
- 使用 `fs.promises` API 实现异步操作

**依赖关系**:
- 依赖：Node.js `fs`, `path` 模块，Electron `app` 模块
- 被依赖：`funasrManager.js` 调用此模块保存录音

---

### MODULE-002: 音频分段处理模块 ✅

**文件**: `src/helpers/audioSegmenter.js`（新建）

**涉及的类**:
- `AudioSegmenter` - 音频分段处理器

**涉及的方法**:
1. `getAudioDuration(audioFilePath)` - 获取音频时长
   - 参数：音频文件路径
   - 功能：调用 FFmpeg 解析音频时长
   - 返回：时长（秒）

2. `shouldSegment(duration)` - 判断是否需要分段
   - 参数：音频时长
   - 功能：判断是否超过 180 秒
   - 返回：`true/false`

3. `segmentAudio(audioFilePath)` - 分段音频
   - 参数：音频文件路径
   - 功能：如果超过 3 分钟，分割成多个片段
   - 返回：`{ success, needsSegmentation, totalDuration, segmentCount, segments }`

4. `extractSegment(inputPath, startTime, duration, outputPath)` - 提取音频片段
   - 参数：输入路径、起始时间、持续时间、输出路径
   - 功能：使用 FFmpeg 提取指定时间段的音频
   - 返回：Promise（无返回值）

5. `cleanupSegments(segments)` - 清理分段文件
   - 参数：分段列表
   - 功能：删除临时分段文件
   - 返回：`{ success }`

6. `mergeTranscriptions(segmentResults)` - 合并转录结果
   - 参数：多个分段的转录结果数组
   - 功能：拼接文本，计算平均置信度
   - 返回：`{ success, text, raw_text, confidence, duration, language, segmentCount }`

**实现思路**:
- 使用 `ffmpeg-static` 提供的 FFmpeg 可执行文件
- FFmpeg 命令：
  - 获取时长：`ffmpeg -i input.wav -hide_banner`（从 stderr 解析）
  - 分割音频：`ffmpeg -i input.wav -ss START -t DURATION -c copy output.wav`
- 临时文件保存在系统临时目录（`os.tmpdir()`）
- 使用 UUID 避免文件名冲突

**依赖关系**:
- 依赖：`ffmpeg-static`, `child_process`, `fs`, `path`, `os`, `crypto`
- 被依赖：`funasrManager.js` 调用此模块进行分段处理

---

### MODULE-003: FunASR 集成调整 ✅

**文件**: `src/helpers/funasrManager.js`（修改现有）

**新增方法**:
`transcribeAudioWithProgress(audioBlob, progressCallback)` - 带进度的转录

**参数**:
- `audioBlob` - 音频数据（Buffer 或 Uint8Array）
- `progressCallback` - 进度回调函数

**功能**:
1. 保存录音到本地（调用 `audioFileManager`）
2. 分析音频时长，判断是否分段（调用 `audioSegmenter`）
3. 如果需要分段：
   - 分割音频
   - 循环转录每段，更新进度
   - 拼接结果
   - 清理临时文件
4. 如果不需要分段：直接转录
5. 返回转录结果（包含录音文件路径）

**返回值**:
```text
{
  success: true,
  text: "转录文本",
  raw_text: "原始文本",
  confidence: 0.95,
  language: "zh-CN",
  duration: 123.45,
  audio_file_path: "recordings/YYYYMMDD_HHMM_recording.wav",
  segment_count: 3,
  was_segmented: true
}
```

**进度回调格式**:
```text
{
  stage: 'saving' | 'analyzing' | 'transcribing' | 'merging',
  message: '正在转录第 2/5 段...',
  current: 2,
  total: 5
}
```

**实现思路**:
- 引入 `audioFileManager` 和 `audioSegmenter` 模块
- 使用时间戳命名录音文件（格式：`YYYYMMDD_HHMM`）
- 循环处理每个分段，调用现有的 `_sendServerCommand` 方法
- 每段完成后通过 `progressCallback` 更新进度
- 最后调用 `mergeTranscriptions` 拼接结果

**依赖关系**:
- 依赖：`audioFileManager`, `audioSegmenter`
- 被依赖：`ipcHandlers.js` 调用此方法

---

### MODULE-004: 数据库扩展 ✅

**文件**: `src/helpers/database.js`（修改现有）

**修改点**:

1. `createTables()` - 添加字段迁移逻辑
   - 检查 `audio_file_path` 字段是否存在
   - 如果不存在，添加此字段
   - 使用 `pragma_table_info` 查询字段信息
   - 安全处理：try-catch 包裹，失败不影响现有功能

2. `saveTranscription(data)` - 修改保存逻辑
   - 在 INSERT 语句中添加 `audio_file_path` 字段
   - 从 `data` 对象中读取 `audio_file_path`（可选）
   - 如果没有，保存为 `null`

**新增字段**:
- `audio_file_path TEXT` - 录音文件相对路径

**数据库迁移安全性**:
- 字段可为 NULL，不影响现有数据
- 使用字段存在性检查，避免重复添加
- 错误时记录日志但不抛出异常

**实现思路**:
- 使用 SQLite 的 `ALTER TABLE ADD COLUMN` 语句
- 向后兼容：旧数据的 `audio_file_path` 为 NULL
- 查询时仍然正常工作

**依赖关系**:
- 无新依赖
- 被依赖：`ipcHandlers.js` 保存转录数据时传入 `audio_file_path`

---

### MODULE-005: UI 进度显示 ✅

**文件**: `src/hooks/useRecording.js`（修改现有）

**新增状态**:
- `segmentProgress` - 分段处理进度状态

**修改点**:

1. **新增 useEffect 监听进度**
   - 使用 `window.electronAPI.onTranscribeProgress` 监听进度事件
   - 更新 `segmentProgress` 状态
   - 返回清理函数（unsubscribe）

2. **修改 `processAudio` 方法**
   - 使用 `transcribeAudioWithProgress` 替代 `transcribeAudio`
   - 转录完成后清除 `segmentProgress` 状态
   - 在 `transcriptionData` 中添加 `audio_file_path` 字段
   - 转录失败时显示提示："转录失败，但录音已保存，可在历史记录中查看"
   - 记录日志："录音已保存: XXX"

3. **新增返回值**
   - 在 hook 的返回对象中添加 `segmentProgress`
   - 组件可以访问进度信息

**进度状态格式**:
```text
{
  stage: 'saving' | 'analyzing' | 'transcribing' | 'merging',
  message: '正在转录第 2/5 段...',
  current: 2,
  total: 5
}
```

**实现思路**:
- 使用 React 的 `useState` 和 `useEffect` 管理进度状态
- 通过 IPC 事件监听主进程的进度更新
- 组件可以根据 `segmentProgress` 显示进度条或提示信息

**依赖关系**:
- 依赖：`window.electronAPI.transcribeAudioWithProgress`, `window.electronAPI.onTranscribeProgress`
- 被依赖：UI 组件使用此 hook 获取进度信息

---

### MODULE-006: IPC 接口扩展 ✅

**文件 1**: `src/helpers/ipcHandlers.js`（修改现有）

**新增 IPC handler**:
- `transcribe-audio-with-progress` - 带进度的转录接口

**实现**:
```text
ipcMain.handle("transcribe-audio-with-progress", async (event, audioData, options) => {
  const webContents = event.sender;
  
  const progressCallback = (progress) => {
    webContents.send('transcribe-progress', progress);
  };
  
  return await this.funasrManager.transcribeAudioWithProgress(audioData, progressCallback);
});
```

**功能**:
- 接收音频数据
- 创建进度回调函数
- 通过 `webContents.send` 发送进度事件
- 返回转录结果

---

**文件 2**: `preload.js`（修改现有）

**新增 API**:

1. `transcribeAudioWithProgress(audioData)` - 调用带进度的转录
   - 返回：Promise（转录结果）

2. `onTranscribeProgress(callback)` - 监听转录进度
   - 参数：回调函数
   - 返回：清理函数（用于取消监听）

**暴露方式**:
```text
contextBridge.exposeInMainWorld("electronAPI", {
  // ... 现有API
  transcribeAudioWithProgress: (audioData) => ipcRenderer.invoke("transcribe-audio-with-progress", audioData),
  onTranscribeProgress: (callback) => {
    ipcRenderer.on("transcribe-progress", callback);
    return () => ipcRenderer.removeListener("transcribe-progress", callback);
  },
  // ... 其他API
});
```

**实现思路**:
- 使用 `ipcRenderer.invoke` 调用主进程方法
- 使用 `ipcRenderer.on` 监听进度事件
- 返回清理函数，避免内存泄漏

**依赖关系**:
- 依赖：Electron `ipcRenderer`
- 被依赖：渲染进程调用这些 API

---

## 遇到的问题

**无**（开发过程顺利）

---

## 关键技术点

### 1. FFmpeg 时长解析
FFmpeg 的时长信息在 stderr 输出中，格式为：
```text
Duration: 00:05:23.45, start: 0.000000, bitrate: 256 kb/s
```

使用正则表达式解析：
```text
const durationMatch = output.match(/Duration: (\d{2}):(\d{2}):(\d{2}\.\d{2})/);
const totalSeconds = hours * 3600 + minutes * 60 + seconds;
```

---

### 2. FFmpeg 音频分割
使用 `-c copy` 参数避免重新编码，速度快：
```text
ffmpeg -i input.wav -ss 180 -t 180 -c copy output.wav
```

- `-ss`：起始时间（秒）
- `-t`：持续时间（秒）
- `-c copy`：直接复制音频流

---

### 3. 临时文件管理
使用 UUID 避免文件名冲突：
```text
const uniqueId = crypto.randomUUID();
const segmentPath = path.join(os.tmpdir(), `segment_${uniqueId}_${i}.wav`);
```

清理策略：
- 每段转录完立即删除
- 最后统一清理所有分段（防止遗漏）

---

### 4. 进度回调机制
主进程通过 `webContents.send` 发送进度事件：
```text
const progressCallback = (progress) => {
  webContents.send('transcribe-progress', progress);
};
```

渲染进程通过 `ipcRenderer.on` 监听：
```text
ipcRenderer.on("transcribe-progress", callback);
```

---

### 5. 数据库字段迁移
安全添加新字段：
```text
const columnCheck = this.db.prepare(`
  SELECT COUNT(*) as count FROM pragma_table_info('transcriptions') 
  WHERE name = 'audio_file_path'
`).get();

if (columnCheck.count === 0) {
  this.db.exec(`ALTER TABLE transcriptions ADD COLUMN audio_file_path TEXT;`);
}
```

---

## 下一步

### MODULE-007: 集成测试和错误处理验证

**测试内容**:
1. 测试短录音（< 3 分钟）
2. 测试长录音（> 3 分钟，分段）
3. 测试文件管理（超过 10 条录音）
4. 测试转换失败场景
5. 测试进度显示
6. 测试数据库字段迁移

**建议用户执行的测试步骤**:
1. 启动应用，录制一段短录音（< 3 分钟）
2. 检查 `recordings/` 目录是否有录音文件
3. 检查数据库中是否有 `audio_file_path` 字段
4. 录制一段长录音（> 3 分钟）
5. 观察是否显示分段处理进度
6. 录制超过 10 条录音，检查是否自动清理旧文件
7. 检查日志文件是否有相关记录

---

## 代码质量说明

- ✅ 所有文件操作使用 try-catch 包裹
- ✅ 所有异步操作使用 async/await
- ✅ 添加详细的中文注释
- ✅ 错误日志记录完善
- ✅ 使用项目相对路径
- ✅ 遵循项目现有代码风格

---

## 总结

本次开发完成了本地录音保留和长录音分段处理的所有核心功能：
- 录音文件保存到项目本地，自动管理数量
- 长录音自动分段处理，降低内存占用
- 实时显示分段处理进度
- 数据库记录录音文件路径
- 失败时提示用户录音已保存

所有模块已实现并集成，待用户在实际运行设备上进行测试验证。

