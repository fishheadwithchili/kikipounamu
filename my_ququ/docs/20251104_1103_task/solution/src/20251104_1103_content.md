# Solution: 本地录音保留与长录音分段处理技术方案

**版本**: 1.0  
**更新时间**: 2025-11-04 11:03:18  
**基于 Background 版本**: 2025-11-04 11:03:18

---

## 技术调研

### 1. 现有技术栈分析

**当前项目使用**：
- **Electron**: 36.5.0 - 桌面应用框架
- **Node.js**: 文件系统操作、子进程管理
- **FFmpeg**: `ffmpeg-static@5.2.0` - 音频处理（已安装）
- **FunASR**: Python 语音识别库
- **better-sqlite3**: 本地数据库
- **React**: UI 组件

**关键现有模块**：
- `src/helpers/funasrManager.js`: FunASR 管理器
- `src/helpers/database.js`: 数据库管理
- `src/hooks/useRecording.js`: 录音逻辑
- `src/helpers/ipcHandlers.js`: IPC 通信处理

---

### 2. FFmpeg 音频处理能力

**已有依赖**：`ffmpeg-static@5.2.0`
- 提供静态编译的 FFmpeg 二进制文件
- 跨平台支持（Windows、macOS、Linux）
- 无需用户额外安装

**音频处理功能**：
1. **获取音频时长**：
```text
ffmpeg -i input.wav -hide_banner 2>&1 | grep Duration
```

2. **分割音频（严格时长）**：
```text
ffmpeg -i input.wav -ss 0 -t 180 -c copy segment_0.wav
ffmpeg -i input.wav -ss 180 -t 180 -c copy segment_1.wav
ffmpeg -i input.wav -ss 360 -t 180 -c copy segment_2.wav
```

3. **参数说明**：
   - `-i`: 输入文件
   - `-ss`: 起始时间（秒）
   - `-t`: 持续时间（秒）
   - `-c copy`: 直接复制音频流（不重新编码，速度快）

**优势**：
- 处理速度快（不重新编码）
- 精度高（严格按时长切分）
- 内存占用低（流式处理）

---

### 3. 文件系统设计

**录音文件夹结构**：
```text
项目根目录/
  ├── recordings/
  │   ├── 20251104_1103_recording.wav
  │   ├── 20251104_1105_recording.wav
  │   ├── ... (最多10条)
  └── ...
```

**文件管理策略**：
- 时间戳命名格式：`YYYYMMDD_HHMM_recording.wav`
- 保留最近 10 条录音
- 超过 10 条时删除最旧的（按文件名排序）
- 使用 Node.js `fs` 模块进行文件操作

**路径处理**：
- 开发模式：`项目根目录/recordings/`
- 生产模式：`process.resourcesPath/../recordings/` 或使用 `app.getPath('userData')/../recordings/`

---

### 4. 数据库扩展

**现有表结构**（`transcriptions`）：
```text
CREATE TABLE transcriptions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  text TEXT NOT NULL,
  raw_text TEXT,
  processed_text TEXT,
  confidence REAL,
  language TEXT DEFAULT 'zh-CN',
  duration REAL,
  file_size INTEGER,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
)
```

**新增字段**：
```text
ALTER TABLE transcriptions ADD COLUMN audio_file_path TEXT;
```

**作用**：
- 保存录音文件相对路径（如 `recordings/20251104_1103_recording.wav`）
- 方便未来查看或回放
- 可选字段（转换失败时也可以保存路径）

---

### 5. 分段处理流程设计

**检测逻辑**：
1. 录音完成后，先保存到本地 `recordings/`
2. 使用 FFmpeg 获取音频时长
3. 判断：
   - 如果 `duration ≤ 180秒`：直接转换
   - 如果 `duration > 180秒`：分段处理

**分段处理流程**：
1. 计算分段数量：`segmentCount = Math.ceil(duration / 180)`
2. 循环分割音频：
   - 第 i 段：`-ss ${i * 180} -t 180`
   - 保存为临时文件：`temp_segment_${i}.wav`
3. 循环转换每段：
   - 调用 FunASR 转录
   - 更新进度：`正在处理第 ${i+1}/${segmentCount} 段`
4. 拼接所有文本结果：
   - 按顺序拼接：`segment_0_text + segment_1_text + ...`
5. 清理临时文件

**内存优化**：
- 每次只处理一个 3 分钟片段
- 处理完立即清理临时文件
- FunASR 服务器保持复用（不重启）

---

## 架构设计

### 模块划分

#### MODULE-001: 录音文件管理模块
**文件**: `src/helpers/audioFileManager.js`

**职责**：
- 创建 `recordings/` 目录
- 保存录音文件（时间戳命名）
- 管理文件数量（最多 10 条）
- 清理旧文件
- 获取录音文件列表

**接口设计**：
```text
class AudioFileManager {
  constructor(logger)
  
  initialize()
    // 创建 recordings/ 目录
  
  saveRecording(audioBlob, timestamp)
    // 保存录音文件，返回文件路径
    // 参数：audioBlob (音频数据), timestamp (时间戳字符串)
    // 返回：{ success: true, filePath: 'recordings/YYYYMMDD_HHMM_recording.wav' }
  
  cleanupOldRecordings()
    // 清理旧录音，保留最近 10 条
  
  getRecordingsList()
    // 获取所有录音文件列表（按时间倒序）
    // 返回：[ { name, path, size, created_at }, ... ]
}
```

---

#### MODULE-002: 音频分段处理模块
**文件**: `src/helpers/audioSegmenter.js`

**职责**：
- 获取音频时长
- 判断是否需要分段
- 分割音频文件
- 管理临时分段文件
- 拼接文本结果

**接口设计**：
```text
class AudioSegmenter {
  constructor(logger)
  
  getAudioDuration(audioFilePath)
    // 获取音频时长（秒）
    // 使用 FFmpeg 解析
    // 返回：duration (number)
  
  shouldSegment(duration)
    // 判断是否需要分段
    // 返回：duration > 180
  
  segmentAudio(audioFilePath, segmentDuration = 180)
    // 分割音频文件
    // 参数：audioFilePath (原始音频), segmentDuration (分段时长，默认180秒)
    // 返回：[ { segmentPath, startTime, duration }, ... ]
  
  cleanupSegments(segmentPaths)
    // 清理临时分段文件
  
  mergeTranscriptions(segmentResults)
    // 拼接多个分段的转录结果
    // 参数：[ { text, raw_text, ... }, ... ]
    // 返回：{ text, raw_text, confidence, ... }
}
```

**FFmpeg 调用示例**：
```text
const ffmpeg = require('ffmpeg-static');
const { spawn } = require('child_process');

// 获取时长
spawn(ffmpeg, ['-i', audioPath, '-hide_banner'], { ... });

// 分割音频
spawn(ffmpeg, ['-i', audioPath, '-ss', '0', '-t', '180', '-c', 'copy', outputPath], { ... });
```

---

#### MODULE-003: FunASR 集成调整
**文件**: `src/helpers/funasrManager.js`（修改现有）

**修改点**：

1. **新增方法：`transcribeAudioWithProgress`**
```text
async transcribeAudioWithProgress(audioBlob, progressCallback)
  // 集成完整流程：
  // 1. 保存到本地 recordings/（调用 audioFileManager）
  // 2. 检测音频时长（调用 audioSegmenter）
  // 3. 判断是否分段
  // 4. 如果分段：
  //    - 分割音频
  //    - 循环转录每段（更新进度）
  //    - 拼接结果
  //    - 清理临时文件
  // 5. 否则：直接转录
  // 6. 返回结果（包含录音文件路径）
  
  // 参数：
  //   audioBlob: 音频数据
  //   progressCallback: (progress) => void
  //     progress: { stage, current, total, message }
  
  // 返回：
  //   { success, text, raw_text, audio_file_path, ... }
```

2. **修改现有方法：`transcribeAudio`**
- 保持向后兼容
- 内部调用 `transcribeAudioWithProgress`

---

#### MODULE-004: 数据库扩展
**文件**: `src/helpers/database.js`（修改现有）

**修改点**：

1. **表结构迁移**
```text
createTables() {
  // 添加迁移逻辑
  this.db.exec(`
    ALTER TABLE transcriptions ADD COLUMN audio_file_path TEXT;
  `);
}
```

2. **修改保存方法**
```text
saveTranscription(data) {
  // 新增字段：audio_file_path
  const stmt = this.db.prepare(`
    INSERT INTO transcriptions (
      text, raw_text, processed_text, confidence,
      language, duration, file_size, audio_file_path
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `);
  
  return stmt.run(
    text.trim(),
    data.raw_text || null,
    data.processed_text || null,
    data.confidence || 0,
    data.language || 'zh-CN',
    data.duration || 0,
    data.file_size || 0,
    data.audio_file_path || null  // 新增
  );
}
```

---

#### MODULE-005: UI 进度显示
**文件**: `src/hooks/useRecording.js` 和相关组件

**修改点**：

1. **新增状态**
```text
const [segmentProgress, setSegmentProgress] = useState(null);
// segmentProgress: { current: 1, total: 5, message: '正在处理第 1/5 段' }
```

2. **修改 `processAudio` 方法**
```text
const processAudio = useCallback(async (audioBlob) => {
  try {
    // 调用新的 transcribeAudioWithProgress 方法
    const result = await window.electronAPI.transcribeAudioWithProgress(
      audioBlob,
      (progress) => {
        // 更新进度状态
        setSegmentProgress(progress);
      }
    );
    
    // 转换成功后显示提示
    if (result.success && result.audio_file_path) {
      // 显示：录音已保存，可在历史记录中查看
      showToast('转录成功，录音已保存到本地');
    }
    
    // 转换失败时也显示提示
    if (!result.success && result.audio_file_path) {
      showToast('转录失败，但录音已保存，可在历史记录中查看');
    }
    
  } catch (err) {
    // 错误处理
  }
}, []);
```

3. **UI 组件调整**
- 在 `App.jsx` 中显示分段进度
- 使用 `sonner` toast 显示提示信息

---

### 数据流图（Mermaid）

```text
graph TD
    A[录音完成] --> B[保存到 recordings/]
    B --> C[检测音频时长]
    C --> D{时长 > 180秒?}
    D -->|是| E[分段处理]
    D -->|否| F[直接转换]
    
    E --> E1[分割音频]
    E1 --> E2[循环处理每段]
    E2 --> E3[更新进度: 第 X/Y 段]
    E3 --> E4[拼接文本结果]
    E4 --> G[保存到数据库]
    
    F --> G
    
    G --> H[显示结果]
    H --> I[提示: 录音已保存]
```

---

## 技术路线

### 阶段 1：录音文件管理（MODULE-001）
1. 创建 `src/helpers/audioFileManager.js`
2. 实现 `AudioFileManager` 类
3. 实现文件保存、清理逻辑
4. 单元测试（手动）

### 阶段 2：音频分段处理（MODULE-002）
1. 创建 `src/helpers/audioSegmenter.js`
2. 实现 `AudioSegmenter` 类
3. 实现 FFmpeg 调用：获取时长、分割音频
4. 实现文本拼接逻辑
5. 单元测试（使用测试音频文件）

### 阶段 3：FunASR 集成（MODULE-003）
1. 修改 `src/helpers/funasrManager.js`
2. 新增 `transcribeAudioWithProgress` 方法
3. 集成 `audioFileManager` 和 `audioSegmenter`
4. 实现进度回调机制
5. 集成测试

### 阶段 4：数据库扩展（MODULE-004）
1. 修改 `src/helpers/database.js`
2. 添加表结构迁移（`audio_file_path` 字段）
3. 修改 `saveTranscription` 方法
4. 数据库测试

### 阶段 5：UI 进度显示（MODULE-005）
1. 修改 `src/hooks/useRecording.js`
2. 新增分段进度状态
3. 修改 `processAudio` 方法
4. 调整 UI 组件（显示进度、提示信息）
5. 集成测试

### 阶段 6：IPC 接口扩展
1. 修改 `src/helpers/ipcHandlers.js`
2. 新增 `transcribe-audio-with-progress` IPC 处理器
3. 支持进度回调（通过 `webContents.send`）
4. 修改 `preload.js` 暴露新接口

### 阶段 7：端到端测试
1. 测试短录音（< 3 分钟）
2. 测试长录音（> 3 分钟，分段）
3. 测试文件管理（超过 10 条录音）
4. 测试转换失败场景
5. 测试进度显示

---

## 关键技术问题解决

### 1. FFmpeg 路径获取
**问题**：如何获取 `ffmpeg-static` 的可执行文件路径？

**解决**：
```text
const ffmpeg = require('ffmpeg-static');
// ffmpeg 是可执行文件的绝对路径
```

---

### 2. FFmpeg 输出解析
**问题**：如何解析 FFmpeg 的输出获取时长？

**解决**：
```text
// FFmpeg 时长输出格式：Duration: 00:05:23.45, start: 0.000000, bitrate: 256 kb/s
const durationMatch = output.match(/Duration: (\d{2}):(\d{2}):(\d{2}\.\d{2})/);
if (durationMatch) {
  const hours = parseInt(durationMatch[1]);
  const minutes = parseInt(durationMatch[2]);
  const seconds = parseFloat(durationMatch[3]);
  const totalSeconds = hours * 3600 + minutes * 60 + seconds;
}
```

---

### 3. 临时文件管理
**问题**：分段文件保存在哪里？如何避免冲突？

**解决**：
```text
const os = require('os');
const crypto = require('crypto');
const tempDir = os.tmpdir();
const uniqueId = crypto.randomUUID();
const segmentPath = path.join(tempDir, `segment_${uniqueId}_${i}.wav`);
```

**清理策略**：
- 每段转录完立即删除
- 最后统一清理所有分段文件（防止遗漏）

---

### 4. 进度回调机制
**问题**：如何实时更新 UI 进度？

**解决**：
```text
// 主进程 (funasrManager.js)
async transcribeAudioWithProgress(audioBlob, webContents, requestId) {
  for (let i = 0; i < segmentCount; i++) {
    // 发送进度更新
    webContents.send('transcribe-progress', {
      requestId,
      current: i + 1,
      total: segmentCount,
      message: `正在处理第 ${i+1}/${segmentCount} 段`
    });
    
    // 转录当前段
    await this.transcribeAudio(segmentPath);
  }
}

// 渲染进程 (useRecording.js)
useEffect(() => {
  const unsubscribe = window.electronAPI.onTranscribeProgress((event, progress) => {
    if (progress.requestId === currentRequestId) {
      setSegmentProgress(progress);
    }
  });
  return unsubscribe;
}, []);
```

---

### 5. 数据库迁移安全性
**问题**：如何安全地添加新字段（避免已有数据库报错）？

**解决**：
```text
createTables() {
  // 检查字段是否已存在
  const columnCheck = this.db.prepare(`
    SELECT COUNT(*) as count FROM pragma_table_info('transcriptions') 
    WHERE name = 'audio_file_path'
  `).get();
  
  if (columnCheck.count === 0) {
    // 字段不存在，添加
    this.db.exec(`
      ALTER TABLE transcriptions ADD COLUMN audio_file_path TEXT;
    `);
    this.logger.info('已添加 audio_file_path 字段');
  }
}
```

---

### 6. 录音文件路径处理
**问题**：开发模式 vs 生产模式的路径差异？

**解决**：
```text
getRecordingsDirectory() {
  const isDev = process.env.NODE_ENV === 'development';
  
  if (isDev) {
    // 开发模式：项目根目录
    return path.join(__dirname, '..', '..', 'recordings');
  } else {
    // 生产模式：应用数据目录
    const { app } = require('electron');
    return path.join(app.getPath('userData'), 'recordings');
  }
}
```

**注意**：生产模式下放在用户数据目录更安全（避免权限问题）

---

## 风险评估和环境提醒

### 风险 1：FFmpeg 分割精度
**风险等级**：低  
**描述**：严格按时长切分可能不在帧边界，导致音频略有损失  
**缓解措施**：
- 使用 `-c copy` 避免重新编码
- FunASR 的 VAD 功能可以处理轻微的音频损失
- 可接受（需求中已明确）

---

### 风险 2：磁盘空间占用
**风险等级**：中  
**描述**：10 条 WAV 录音可能占用较大空间（每条约 1-10 MB）  
**缓解措施**：
- 限制数量为 10
- 自动清理机制
- 未来可考虑压缩（如转为 MP3）

---

### 风险 3：分段处理时间增加
**风险等级**：中  
**描述**：长录音分段处理总时间可能略长于一次性处理  
**缓解措施**：
- 显示详细进度，让用户了解状态
- FFmpeg 分割速度很快（不重新编码）
- FunASR 模型保持加载，避免重复初始化

---

### 风险 4：并发录音冲突
**风险等级**：低  
**描述**：用户快速连续录音可能导致文件名冲突  
**缓解措施**：
- 时间戳精确到分钟，通常不会冲突
- 如果冲突，添加随机后缀

---

### 风险 5：数据库迁移失败
**风险等级**：低  
**描述**：添加新字段时可能失败（文件损坏、权限问题）  
**缓解措施**：
- 使用字段存在性检查
- 添加 try-catch 错误处理
- 失败时不影响现有功能

---

## 版本要求和兼容性

### Node.js 版本
- **要求**：Node.js 14+ (Electron 36.5.0 内置)
- **兼容性**：无问题

### FFmpeg 版本
- **依赖**：`ffmpeg-static@5.2.0`
- **兼容性**：支持所有平台（Windows、macOS、Linux）

### Python 版本
- **要求**：Python 3.10.11（用户环境）
- **兼容性**：FunASR 无变更，无影响

### 数据库
- **依赖**：`better-sqlite3@11.10.0`
- **兼容性**：向后兼容（新增字段可为 NULL）

---

## 是否需要独立环境

**结论**：不需要

**理由**：
- 所有新增功能都在现有 Node.js 环境中实现
- FFmpeg 通过 `ffmpeg-static` 提供，无需额外安装
- Python 环境无变更
- 不涉及新的系统依赖

---

## 测试策略

### 单元测试
- **MODULE-001**：测试文件保存、清理逻辑
- **MODULE-002**：测试 FFmpeg 调用、时长检测、分割逻辑
- **MODULE-003**：测试 FunASR 集成
- **MODULE-004**：测试数据库字段添加、保存

### 集成测试
- 测试完整流程：录音 → 保存 → 分段 → 转换 → 数据库
- 测试短录音和长录音场景
- 测试文件管理（超过 10 条）

### 性能测试
- 测试 3 分钟录音转换时间
- 测试 10 分钟录音分段处理时间
- 测试 FFmpeg 分割速度

### 用户体验测试
- 测试进度显示是否流畅
- 测试提示信息是否清晰
- 测试转换失败场景

---

## 后续优化方向

### 优化 1：录音压缩
- 将 WAV 转为 MP3 或 OGG 格式
- 减少磁盘占用

### 优化 2：配置项
- 允许用户配置录音保留数量（默认 10）
- 允许用户配置分段时长（默认 180 秒）

### 优化 3：录音回放功能
- 在历史记录界面添加播放按钮
- 使用 HTML5 Audio 播放

### 优化 4：智能切分
- 在 3 分钟附近寻找静音点切分
- 使用 FunASR 的 VAD 模型检测静音

### 优化 5：云端备份
- 可选的云端存储（如对象存储）
- 自动同步录音文件

---

## 开发注意事项

### 1. 错误处理
- 所有文件操作都需要 try-catch
- FFmpeg 调用失败时回退到不分段处理
- 数据库操作失败时不影响转录功能

### 2. 日志记录
- 使用 `logManager` 记录关键操作
- 记录 FFmpeg 输出（用于调试）
- 记录分段处理进度

### 3. 代码风格
- 遵循项目现有风格
- 使用中文注释说明关键逻辑
- 避免过度抽象

### 4. 性能优化
- 避免阻塞主进程
- 使用异步操作（async/await）
- 及时清理临时文件和内存

---

## 总结

本方案通过引入录音文件管理和音频分段处理机制，解决了录音丢失和内存占用问题。技术实现基于现有技术栈，无需额外依赖，风险可控。开发分 7 个阶段，逐步实现各模块功能，最后进行端到端测试。预计开发工作量约 2-3 天。

